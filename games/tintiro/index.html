<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D 粋・極チンチロ</title>
    <style>
        body { margin: 0; background: #0b0b0b; overflow: hidden; font-family: "Yu Mincho", serif; }
        #ui { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10; }
        #result-container { 
            position: absolute; top: 15%; width: 100%; text-align: center; 
            pointer-events: none; z-index: 20; 
        }
        #yaku { font-size: 64px; font-weight: bold; color: #d4af37; text-shadow: 0 0 15px rgba(212, 175, 55, 0.6); margin: 0; opacity: 0; }
        #dice-vals { font-size: 24px; color: #fff; opacity: 0; margin-top: 10px; letter-spacing: 5px; }
        
        button { 
            padding: 15px 50px; font-size: 22px; background: linear-gradient(to bottom, #d4af37, #aa8a2e); 
            border: 1px solid #333; cursor: pointer; border-radius: 4px; font-family: inherit; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); color: #1a1a1a;
        }
        button:disabled { background: #444; color: #888; cursor: not-allowed; opacity: 0.6; }

        .impact { animation: yakuIn 0.5s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        @keyframes yakuIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

<div id="result-container">
    <p id="yaku"></p>
    <p id="dice-vals"></p>
</div>

<div id="ui">
    <button id="rollBtn">勝負を振る</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
let world, scene, camera, renderer, diceArray = [], diceBodies = [];
let isRolling = false;
let checkSettled = false;

function createDiceTexture(number) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fdfdfd';
    ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = (number === 1) ? '#e63946' : '#222';
    const r = (number === 1) ? 22 : 12;
    const c = 64, l = 30, h = 98;
    const dots = {
        1: [[c, c]],
        2: [[l, h], [h, l]],
        3: [[l, h], [c, c], [h, l]],
        4: [[l, l], [l, h], [h, l], [h, h]],
        5: [[l, l], [l, h], [c, c], [h, l], [h, h]],
        6: [[l, l], [l, 64], [l, h], [h, l], [h, 64], [h, h]]
    };
    dots[number].forEach(pos => {
        ctx.beginPath(); ctx.arc(pos[0], pos[1], r, 0, Math.PI * 2); ctx.fill();
    });
    return new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas) });
}

function init() {
    world = new CANNON.World();
    world.gravity.set(0, -25, 0); 
    
    const mat = new CANNON.Material();
    world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { restitution: 0.6, friction: 0.1 }));

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 14, 10);
    camera.lookAt(0, -1, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0a0a0a);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const light = new THREE.SpotLight(0xffffff, 1);
    light.position.set(5, 20, 5);
    light.castShadow = true;
    scene.add(light);

    // --- すり鉢状のお椀の物理作成 ---
    const radius = 5;
    const segments = 24;
    const vertices = [];
    const indices = [];
    
    // 中心点
    vertices.push(0, 0, 0); 
    // 円周上の点（少し浮かせてすり鉢にする）
    for (let i = 0; i < segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        vertices.push(Math.cos(theta) * radius, 1.5, Math.sin(theta) * radius);
    }
    // 面の作成
    for (let i = 1; i <= segments; i++) {
        indices.push(0, i, i === segments ? 1 : i + 1);
    }

    const bowlShape = new CANNON.Trimesh(vertices, indices);
    const bowlBody = new CANNON.Body({ mass: 0, material: mat });
    bowlBody.addShape(bowlShape);
    world.addBody(bowlBody);

    // お椀の見た目
    const bowlGeo = new THREE.CylinderGeometry(radius, radius*0.7, 2, segments, 1, false);
    const bowlMat = new THREE.MeshPhongMaterial({ color: 0x3d0000, side: THREE.DoubleSide });
    const bowlMesh = new THREE.Mesh(bowlGeo, bowlMat);
    bowlMesh.position.y = 0.5;
    bowlMesh.receiveShadow = true;
    scene.add(bowlMesh);

    // サイコロ
    const diceSize = 0.7;
    const diceMats = [
        createDiceTexture(5), createDiceTexture(2),
        createDiceTexture(6), createDiceTexture(1),
        createDiceTexture(3), createDiceTexture(4)
    ];

    for (let i = 0; i < 3; i++) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(diceSize, diceSize, diceSize), diceMats);
        mesh.castShadow = true;
        scene.add(mesh);
        diceArray.push(mesh);

        const body = new CANNON.Body({ mass: 1, material: mat });
        body.addShape(new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)));
        body.position.set(i-1, 20, 0); // 高い位置から
        body.sleepSpeedLimit = 0.1; 
        world.addBody(body);
        diceBodies.push(body);
    }

    animate();
}

function roll() {
    if (isRolling) return;
    isRolling = true;
    checkSettled = false;
    document.getElementById('yaku').style.opacity = 0;
    document.getElementById('dice-vals').style.opacity = 0;
    document.getElementById('yaku').classList.remove('impact');
    document.getElementById('rollBtn').disabled = true;

    diceBodies.forEach((body, i) => {
        body.position.set((Math.random()-0.5)*2, 6 + i, (Math.random()-0.5)*2);
        body.velocity.set((Math.random()-0.5)*15, -15, (Math.random()-0.5)*15);
        body.angularVelocity.set(Math.random()*40, Math.random()*40, Math.random()*40);
    });

    // 2秒後から停止チェックを開始
    setTimeout(() => { checkSettled = true; }, 2000);
}

function checkAllSettled() {
    if (!checkSettled) return;

    // 全てのサイコロの速度と角速度の合計が極低速なら「停止」とみなす
    const isStopped = diceBodies.every(body => 
        body.velocity.length() < 0.05 && body.angularVelocity.length() < 0.05
    );

    if (isStopped) {
        checkSettled = false;
        judge();
    }
}

function judge() {
    const results = diceBodies.map(body => {
        const matrix = new THREE.Matrix4().makeRotationFromQuaternion(
            new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w)
        );
        const localDirs = [
            {v: new THREE.Vector3(1,0,0), val: 5}, {v: new THREE.Vector3(-1,0,0), val: 2},
            {v: new THREE.Vector3(0,1,0), val: 6}, {v: new THREE.Vector3(0,-1,0), val: 1},
            {v: new THREE.Vector3(0,0,1), val: 3}, {v: new THREE.Vector3(0,0,-1), val: 4}
        ];
        let maxDot = -1, res = 1;
        localDirs.forEach(dir => {
            const dot = dir.v.clone().applyMatrix4(matrix).dot(new THREE.Vector3(0, 1, 0));
            if (dot > maxDot) { maxDot = dot; res = dir.val; }
        });
        return res;
    });

    displayResult(results);
    isRolling = false;
    document.getElementById('rollBtn').disabled = false;
}

function displayResult(res) {
    res.sort((a, b) => a - b);
    let title = "役なし", color = "#fff";

    if (res[0] === res[1] && res[1] === res[2]) {
        if (res[0] === 1) { title = "ピンゾロ (5倍)"; color = "#ff4d4d"; }
        else { title = `ゾロ目 (${res[0]}) (3倍)`; color = "#d4af37"; }
    } else if (res[0] === 4 && res[1] === 5 && res[2] === 6) {
        title = "シゴロ (2倍)"; color = "#d4af37";
    } else if (res[0] === 1 && res[1] === 2 && res[2] === 3) {
        title = "ヒフミ (2倍払)"; color = "#4d94ff";
    } else {
        if (res[0] === res[1]) title = `${res[2]}の目`;
        else if (res[1] === res[2]) title = `${res[0]}の目`;
        else if (res[0] === res[2]) title = `${res[1]}の目`;
    }

    const yakuEl = document.getElementById('yaku');
    const valsEl = document.getElementById('dice-vals');
    yakuEl.textContent = title;
    yakuEl.style.color = color;
    valsEl.textContent = `出目: ${res.join(" ")}`;
    yakuEl.classList.add('impact');
    valsEl.style.opacity = 0.8;
}

function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    checkAllSettled();
    diceArray.forEach((mesh, i) => {
        mesh.position.copy(diceBodies[i].position);
        mesh.quaternion.copy(diceBodies[i].quaternion);
    });
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('rollBtn').onclick = roll;
init();
</script>
</body>
</html>
