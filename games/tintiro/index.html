<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D 粋・極チンチロ 盆踊り版</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: "Yu Mincho", serif; }
        #ui { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 100; }
        #result-container { position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 110; }
        #yaku { font-size: 80px; font-weight: bold; margin: 0; opacity: 0; letter-spacing: 12px; }
        #dice-vals { font-size: 24px; color: #fff; opacity: 0; margin-top: 10px; letter-spacing: 5px; }
        button { 
            padding: 20px 70px; font-size: 26px; background: linear-gradient(135deg, #d4af37 0%, #fef1a2 50%, #aa8a2e 100%); 
            border: 2px solid #554411; cursor: pointer; border-radius: 60px; font-family: inherit; font-weight: bold;
            box-shadow: 0 8px 25px rgba(0,0,0,0.9); color: #1a1a1a; transition: 0.2s;
        }
        button:active { transform: scale(0.95); }
        button:disabled { background: #333; color: #666; cursor: not-allowed; border-color: #222; opacity: 0.5; }

        .impact { animation: yakuIn 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        @keyframes yakuIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .shake { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(-8px, 8px); } 50% { transform: translate(8px, -8px); } 75% { transform: translate(-8px, -8px); } }
    </style>
</head>
<body>

<div id="result-container">
    <p id="yaku"></p>
    <p id="dice-vals"></p>
</div>

<div id="ui"><button id="rollBtn">丁半、勝負</button></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
let world, scene, camera, renderer, diceArray = [], diceBodies = [];
let isRolling = false, checkSettled = false;

// --- テクスチャ生成 ---
function createDiceTexture(num) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = (num === 1) ? '#e63946' : '#111';
    const r = (num === 1) ? 24 : 14;
    const c = 64, l = 30, h = 98;
    const dots = { 
        1:[[c,c]], 2:[[l,h],[h,l]], 3:[[l,h],[c,c],[h,l]], 
        4:[[l,l],[l,h],[h,l],[h,h]], 5:[[l,l],[l,h],[c,c],[h,l],[h,h]], 
        6:[[l,l],[l,64],[l,h],[h,l],[h,64],[h,h]] 
    };
    dots[num].forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], r, 0, Math.PI*2); ctx.fill(); });
    return new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas), shininess: 100 });
}

function createTrayTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
    grad.addColorStop(0, '#5d291e'); // 中心
    grad.addColorStop(1, '#2a0d08'); // 外側
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 512, 512);
    // 木目風のノイズ
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    for(let i=0; i<100; i++){
        ctx.beginPath();
        ctx.arc(256 + (Math.random()-0.5)*100, 256 + (Math.random()-0.5)*100, Math.random()*400, 0, Math.PI*2);
        ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
}

function init() {
    // 物理世界
    world = new CANNON.World();
    world.gravity.set(0, -60, 0);
    world.allowSleep = true;

    const mat = new CANNON.Material();
    world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { 
        restitution: 0.8, // 反発を適度にしジッターを防ぐ
        friction: 0.2 
    }));

    // Three.js シーン
    scene = new THREE.Scene();
    // カメラを真上（Y軸上）に配置
    camera = new THREE.PerspectiveCamera(30, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 22, 0); 
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(5, 15, 5);
    light.castShadow = true;
    scene.add(light);

    // --- お盆（地面） ---
    const trayRadius = 5;
    
    // 物理地面（底）
    const floor = new CANNON.Body({ mass: 0, material: mat });
    floor.addShape(new CANNON.Plane());
    floor.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
    world.addBody(floor);

    // 垂直な見えない壁（円状に配置）
    for(let i=0; i<16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const x = Math.cos(angle) * trayRadius;
        const z = Math.sin(angle) * trayRadius;
        const wall = new CANNON.Body({ mass: 0, material: mat });
        wall.addShape(new CANNON.Plane());
        wall.position.set(x, 0, z);
        const qY = new CANNON.Quaternion(); qY.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle + Math.PI);
        wall.quaternion = qY;
        world.addBody(wall);
    }

    // お盆の見た目
    const trayGeo = new THREE.CircleGeometry(trayRadius, 64);
    const trayMat = new THREE.MeshPhongMaterial({ map: createTrayTexture(), shininess: 20 });
    const trayMesh = new THREE.Mesh(trayGeo, trayMat);
    trayMesh.rotation.x = -Math.PI/2;
    trayMesh.receiveShadow = true;
    scene.add(trayMesh);

    // お盆の縁（見た目用）
    const rimGeo = new THREE.TorusGeometry(trayRadius, 0.2, 16, 100);
    const rimMat = new THREE.MeshPhongMaterial({ color: 0x1a0a05 });
    const rimMesh = new THREE.Mesh(rimGeo, rimMat);
    rimMesh.rotation.x = Math.PI/2;
    scene.add(rimMesh);

    // サイコロ
    const diceSize = 0.8;
    const diceMats = [createDiceTexture(5), createDiceTexture(2), createDiceTexture(6), createDiceTexture(1), createDiceTexture(3), createDiceTexture(4)];
    for (let i = 0; i < 3; i++) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(diceSize, diceSize, diceSize), diceMats);
        mesh.castShadow = true;
        scene.add(mesh);
        diceArray.push(mesh);
        
        const body = new CANNON.Body({ mass: 1, material: mat });
        body.addShape(new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)));
        body.position.set(0, 10, 0);
        body.sleepTimeLimit = 0.5;
        body.sleepSpeedLimit = 0.2;
        world.addBody(body);
        diceBodies.push(body);
    }
    
    animate();
}

function roll() {
    if (isRolling) return;
    isRolling = true; checkSettled = false;
    document.getElementById('yaku').style.opacity = 0;
    document.getElementById('dice-vals').style.opacity = 0;
    document.getElementById('rollBtn').disabled = true;

    diceBodies.forEach((body, i) => {
        body.wakeUp();
        body.position.set((Math.random()-0.5)*2, 5 + i, (Math.random()-0.5)*2);
        // 真上視点なので水平方向に強く弾く
        body.velocity.set((Math.random()-0.5)*35, -20, (Math.random()-0.5)*35);
        body.angularVelocity.set(Math.random()*40, Math.random()*40, Math.random()*40);
    });
    setTimeout(() => { checkSettled = true; }, 1000);
}

function checkAllSettled() {
    if (!checkSettled) return;
    const stopped = diceBodies.every(b => b.sleepState === CANNON.Body.SLEEPING || (b.velocity.length() < 0.1 && b.angularVelocity.length() < 0.1));
    if (stopped) { checkSettled = false; judge(); }
}

function judge() {
    const results = diceBodies.map(body => {
        const matrix = new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w));
        const localDirs = [{v: new THREE.Vector3(1,0,0), val: 5}, {v: new THREE.Vector3(-1,0,0), val: 2}, {v: new THREE.Vector3(0,1,0), val: 6}, {v: new THREE.Vector3(0,-1,0), val: 1}, {v: new THREE.Vector3(0,0,1), val: 3}, {v: new THREE.Vector3(0,0,-1), val: 4}];
        let maxDot = -1, res = 1;
        localDirs.forEach(dir => {
            const dot = dir.v.clone().applyMatrix4(matrix).dot(new THREE.Vector3(0, 1, 0));
            if (dot > maxDot) { maxDot = dot; res = dir.val; }
        });
        return res;
    });

    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 400);

    results.sort((a, b) => a - b);
    let title = "役なし", color = "#fff";
    if (results[0] === results[1] && results[1] === results[2]) {
        if (results[0] === 1) { title = "ピンゾロ (5倍)"; color = "#ff4d4d"; }
        else { title = `ゾロ目 (${results[0]}) (3倍)`; color = "#ffd700"; }
    } else if (results[0] === 4 && results[1] === 5 && results[2] === 6) { title = "シゴロ (2倍)"; color = "#ffd700";
    } else if (results[0] === 1 && results[1] === 2 && results[2] === 3) { title = "ヒフミ (2倍払)"; color = "#4d94ff";
    } else {
        if (results[0] === results[1]) title = `${results[2]}の目`;
        else if (results[1] === results[2]) title = `${results[0]}の目`;
        else if (results[0] === results[2]) title = `${results[1]}の目`;
    }

    const yakuEl = document.getElementById('yaku');
    yakuEl.textContent = title; yakuEl.style.color = color;
    document.getElementById('dice-vals').textContent = `出目: ${results.join(" ")}`;
    yakuEl.classList.add('impact'); document.getElementById('dice-vals').style.opacity = 0.8;
    isRolling = false; document.getElementById('rollBtn').disabled = false;
}

function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    checkAllSettled();
    diceArray.forEach((mesh, i) => {
        mesh.position.copy(diceBodies[i].position);
        mesh.quaternion.copy(diceBodies[i].quaternion);
    });
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('rollBtn').onclick = roll;
init();
</script>
</body>
</html>
