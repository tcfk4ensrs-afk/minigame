<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D 粋・デジタルチンチロ</title>
    <style>
        body { margin: 0; background: #0b0b0b; overflow: hidden; font-family: "Yu Mincho", serif; }
        #ui { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10; }
        #result-container { 
            position: absolute; top: 15%; width: 100%; text-align: center; 
            pointer-events: none; z-index: 20; 
        }
        #yaku { font-size: 64px; font-weight: bold; color: #d4af37; text-shadow: 0 0 15px rgba(212, 175, 55, 0.6); margin: 0; opacity: 0; }
        #dice-vals { font-size: 24px; color: #fff; opacity: 0.8; margin-top: 10px; letter-spacing: 5px; opacity: 0; }
        
        button { 
            padding: 15px 50px; font-size: 22px; background: linear-gradient(to bottom, #d4af37, #aa8a2e); 
            border: 1px solid #333; cursor: pointer; border-radius: 4px; font-family: inherit; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); color: #1a1a1a;
        }
        button:active { transform: translateY(2px); box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }

        .impact { animation: yakuIn 0.5s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        @keyframes yakuIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

<div id="result-container">
    <p id="yaku"></p>
    <p id="dice-vals"></p>
</div>

<div id="ui">
    <button id="rollBtn">勝負を振る</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
let world, scene, camera, renderer, diceArray = [], diceBodies = [];
let isRolling = false;

// サイコロの面と対応するベクトル (Three.jsのBoxGeometry基準)
// 1: Z+, 2: Z-, 3: Y+, 4: Y-, 5: X+, 6: X-
const faceData = [
    { val: 1, vec: new THREE.Vector3(0, 0, 1) },
    { val: 2, vec: new THREE.Vector3(0, 0, -1) },
    { val: 6, vec: new THREE.Vector3(0, 1, 0) }, // 上面
    { val: 1, vec: new THREE.Vector3(0, -1, 0) }, // 下面(1は赤にするため特殊処理)
    { val: 4, vec: new THREE.Vector3(1, 0, 0) },
    { val: 3, vec: new THREE.Vector3(-1, 0, 0) }
];

// 正しいサイコロのドット配置（標準的な配置）
function createDiceTexture(number) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // 背景
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, 128, 128);
    
    // ドットを描画
    ctx.fillStyle = (number === 1) ? '#e63946' : '#222';
    const r = (number === 1) ? 18 : 10;
    const center = 64, low = 32, high = 96;

    const dots = {
        1: [[center, center]],
        2: [[low, high], [high, low]],
        3: [[low, high], [center, center], [high, low]],
        4: [[low, low], [low, high], [high, low], [high, high]],
        5: [[low, low], [low, high], [center, center], [high, low], [high, high]],
        6: [[low, low], [low, 64], [low, high], [high, low], [high, 64], [high, high]]
    };

    dots[number].forEach(pos => {
        ctx.beginPath();
        ctx.arc(pos[0], pos[1], r, 0, Math.PI * 2);
        ctx.fill();
    });

    const texture = new THREE.CanvasTexture(canvas);
    return new THREE.MeshPhongMaterial({ map: texture });
}

function init() {
    // --- 物理世界 ---
    world = new CANNON.World();
    world.gravity.set(0, -20, 0); // 重力を強めてキビキビ動かす
    
    const defaultMaterial = new CANNON.Material('default');
    const contactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
        restitution: 0.7, // 反発係数（跳ねる！）
        friction: 0.3
    });
    world.addContactMaterial(contactMaterial);

    // --- 3D空間 ---
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 12);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0b0b0b);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 15, 5);
    light.castShadow = true;
    scene.add(light);

    // どんぶり
    const bowlGeo = new THREE.CylinderGeometry(6, 4.5, 2, 32, 1, true);
    const bowlMat = new THREE.MeshPhongMaterial({ color: 0x4a0404, side: THREE.DoubleSide });
    const bowl = new THREE.Mesh(bowlGeo, bowlMat);
    bowl.receiveShadow = true;
    scene.add(bowl);

    const floorGeo = new THREE.CircleGeometry(6, 32);
    const floor = new THREE.Mesh(floorGeo, bowlMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // 物理的な床
    const groundBody = new CANNON.Body({ mass: 0, material: defaultMaterial });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    world.addBody(groundBody);

    // 見えない壁（外に出ないように）
    for(let i=0; i<4; i++) {
        const wall = new CANNON.Body({ mass: 0, material: defaultMaterial });
        wall.addShape(new CANNON.Plane());
        const angle = (Math.PI/2) * i;
        wall.position.set(Math.cos(angle)*6, 0, Math.sin(angle)*6);
        wall.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle - Math.PI/2);
        world.addBody(wall);
    }

    // サイコロ3つ生成
    const diceSize = 0.7;
    // BoxGeometryの面順序: px, nx, py, ny, pz, nz
    // px=5, nx=2, py=6, ny=1, pz=3, nz=4 に対応
    const materials = [
        createDiceTexture(5), createDiceTexture(2),
        createDiceTexture(6), createDiceTexture(1),
        createDiceTexture(3), createDiceTexture(4)
    ];

    for (let i = 0; i < 3; i++) {
        const diceMesh = new THREE.Mesh(new THREE.BoxGeometry(diceSize, diceSize, diceSize), materials);
        diceMesh.castShadow = true;
        scene.add(diceMesh);
        diceArray.push(diceMesh);

        const body = new CANNON.Body({ mass: 1, material: defaultMaterial });
        body.addShape(new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)));
        body.position.set(i-1, 15, 0); // 場外から落とす
        world.addBody(body);
        diceBodies.push(body);
    }

    animate();
}

function roll() {
    if (isRolling) return;
    isRolling = true;
    document.getElementById('yaku').classList.remove('impact');
    document.getElementById('yaku').style.opacity = 0;
    document.getElementById('dice-vals').style.opacity = 0;
    document.getElementById('rollBtn').disabled = true;

    diceBodies.forEach((body, i) => {
        body.position.set(Math.random()-0.5, 7 + i, Math.random()-0.5);
        const force = 15;
        body.velocity.set((Math.random()-0.5)*force, -10, (Math.random()-0.5)*force);
        body.angularVelocity.set(Math.random()*30, Math.random()*30, Math.random()*30);
    });

    setTimeout(judge, 3500);
}

function judge() {
    const results = diceBodies.map(body => {
        const matrix = new THREE.Matrix4().makeRotationFromQuaternion(
            new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w)
        );
        
        let maxDot = -1;
        let result = 1;
        
        // 1:nx, 2:px, 3:ny, 4:py, 5:nz, 6:pz (Boxの面定義に合わせる)
        const localDirs = [
            {v: new THREE.Vector3(1,0,0), val: 5},
            {v: new THREE.Vector3(-1,0,0), val: 2},
            {v: new THREE.Vector3(0,1,0), val: 6},
            {v: new THREE.Vector3(0,-1,0), val: 1},
            {v: new THREE.Vector3(0,0,1), val: 3},
            {v: new THREE.Vector3(0,0,-1), val: 4}
        ];

        localDirs.forEach(dir => {
            const worldDir = dir.v.clone().applyMatrix4(matrix);
            const dot = worldDir.dot(new THREE.Vector3(0, 1, 0));
            if (dot > maxDot) {
                maxDot = dot;
                result = dir.val;
            }
        });
        return result;
    });

    displayResult(results);
    isRolling = false;
    document.getElementById('rollBtn').disabled = false;
}

function displayResult(res) {
    res.sort((a, b) => a - b);
    let title = "役なし";
    let color = "#fff";

    if (res[0] === res[1] && res[1] === res[2]) {
        if (res[0] === 1) { title = "ピンゾロ (5倍)"; color = "#ff4d4d"; }
        else { title = `ゾロ目 (${res[0]}) (3倍)`; color = "#d4af37"; }
    } else if (res[0] === 4 && res[1] === 5 && res[2] === 6) {
        title = "シゴロ (2倍)"; color = "#d4af37";
    } else if (res[0] === 1 && res[1] === 2 && res[2] === 3) {
        title = "ヒフミ (2倍払)"; color = "#4d94ff";
    } else {
        if (res[0] === res[1]) title = `${res[2]}の目`;
        else if (res[1] === res[2]) title = `${res[0]}の目`;
        else if (res[0] === res[2]) title = `${res[1]}の目`;
    }

    const yakuEl = document.getElementById('yaku');
    const valsEl = document.getElementById('dice-vals');
    yakuEl.textContent = title;
    yakuEl.style.color = color;
    valsEl.textContent = `出目: ${res.join(" ")}`;
    
    yakuEl.classList.add('impact');
    valsEl.style.opacity = 0.8;
}

function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    diceArray.forEach((mesh, i) => {
        mesh.position.copy(diceBodies[i].position);
        mesh.quaternion.copy(diceBodies[i].quaternion);
    });
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('rollBtn').onclick = roll;
init();
</script>
</body>
</html>
