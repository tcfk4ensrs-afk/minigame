<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D 粋・極チンチロ 究極版</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: "Yu Mincho", serif; }
        #ui { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 100; }
        #result-container { position: absolute; top: 15%; width: 100%; text-align: center; pointer-events: none; z-index: 110; }
        #yaku { font-size: 72px; font-weight: bold; margin: 0; opacity: 0; letter-spacing: 8px; }
        #dice-vals { font-size: 24px; color: #fff; opacity: 0; margin-top: 10px; letter-spacing: 5px; }
        button { 
            padding: 18px 60px; font-size: 24px; background: linear-gradient(135deg, #d4af37 0%, #fef1a2 50%, #aa8a2e 100%); 
            border: 2px solid #554411; cursor: pointer; border-radius: 50px; font-family: inherit; font-weight: bold;
            box-shadow: 0 6px 20px rgba(0,0,0,0.8); color: #1a1a1a;
        }
        button:disabled { background: #333; color: #666; cursor: not-allowed; border-color: #222; }
        .impact { animation: yakuIn 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.49) forwards; }
        @keyframes yakuIn { 0% { transform: scale(0.3); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .shake { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translate(0,0); } 20% { transform: translate(-10px, 10px); } 40% { transform: translate(10px, -10px); } 60% { transform: translate(-10px, -10px); } 80% { transform: translate(10px, 10px); } }
    </style>
</head>
<body>

<div id="result-container">
    <p id="yaku"></p>
    <p id="dice-vals"></p>
</div>

<div id="ui"><button id="rollBtn">丁半、勝負</button></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
let world, scene, camera, renderer, diceArray = [], diceBodies = [], particles = [];
let isRolling = false, checkSettled = false;

function createDiceTexture(num) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = (num === 1) ? '#e63946' : '#111';
    const r = (num === 1) ? 22 : 12;
    const c = 64, l = 30, h = 98;
    const dots = { 1:[[c,c]], 2:[[l,h],[h,l]], 3:[[l,h],[c,c],[l,h]], 3:[[l,h],[c,c],[h,l]], 4:[[l,l],[l,h],[h,l],[h,h]], 5:[[l,l],[l,h],[c,c],[h,l],[h,h]], 6:[[l,l],[l,64],[l,h],[h,l],[h,64],[h,h]] };
    dots[num].forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], r, 0, Math.PI*2); ctx.fill(); });
    return new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas), shininess: 80 });
}

function init() {
    // 物理世界：重力と反発を大幅強化
    world = new CANNON.World();
    world.gravity.set(0, -50, 0);
    const mat = new CANNON.Material();
    world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { restitution: 0.8, friction: 0.05 }));

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 18, 14); camera.lookAt(0, -1, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x050505); renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.PointLight(0xffffff, 1.2);
    light.position.set(0, 20, 10); light.castShadow = true;
    scene.add(light);

    // --- 物理設定：器の構造 ---
    const floorSize = 2.0; 
    const bowlRadius = 4.5;
    const tilt = 0.8; 
    
    // 底面
    const floor = new CANNON.Body({ mass: 0, material: mat });
    floor.addShape(new CANNON.Plane());
    floor.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
    world.addBody(floor);

    const createWall = (x, z, ry, rx, isInvisible = false) => {
        const b = new CANNON.Body({ mass: 0, material: mat });
        b.addShape(new CANNON.Plane()); b.position.set(x, 0, z);
        const qY = new CANNON.Quaternion(); qY.setFromAxisAngle(new CANNON.Vec3(0,1,0), ry);
        const qX = new CANNON.Quaternion(); qX.setFromAxisAngle(new CANNON.Vec3(1,0,0), rx);
        b.quaternion = qY.mult(qX); world.addBody(b);
    };

    // 滑り台（坂）
    createWall(0, floorSize, 0, -Math.PI/2 + tilt);
    createWall(0, -floorSize, Math.PI, -Math.PI/2 + tilt);
    createWall(floorSize, 0, -Math.PI/2, -Math.PI/2 + tilt);
    createWall(-floorSize, 0, Math.PI/2, -Math.PI/2 + tilt);

    // 見えない垂直壁（場外防止ガード）
    createWall(0, bowlRadius, 0, -Math.PI);     // 北
    createWall(0, -bowlRadius, 0, 0);           // 南
    createWall(bowlRadius, 0, -Math.PI/2, 0);   // 東
    createWall(-bowlRadius, 0, Math.PI/2, 0);    // 西

    // --- 描画設定：お椀 (透明度と深度テストを調整してサイコロを隠さないように) ---
    const bowlMat = new THREE.MeshPhongMaterial({ color: 0x4a0000, side: THREE.DoubleSide, transparent: true, opacity: 0.9, depthWrite: true });
    
    // 描画用の器
    const vFloor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize*2, floorSize*2), bowlMat);
    vFloor.rotation.x = -Math.PI/2; vFloor.receiveShadow = true; scene.add(vFloor);

    const wallGeo = new THREE.PlaneGeometry(bowlRadius * 2.5, 6);
    const setupVWall = (x, z, ry, rx) => {
        const m = new THREE.Mesh(wallGeo, bowlMat);
        m.position.set(x, 2, z); m.rotation.y = ry; m.rotation.x = rx; m.receiveShadow = true;
        scene.add(m);
    };
    setupVWall(0, floorSize, 0, -Math.PI/2 + tilt);
    setupVWall(0, -floorSize, Math.PI, -Math.PI/2 + tilt);
    setupVWall(floorSize, 0, -Math.PI/2, -Math.PI/2 + tilt);
    setupVWall(-floorSize, 0, Math.PI/2, -Math.PI/2 + tilt);

    // サイコロ
    const diceSize = 0.8;
    const diceMats = [createDiceTexture(5), createDiceTexture(2), createDiceTexture(6), createDiceTexture(1), createDiceTexture(3), createDiceTexture(4)];
    for (let i = 0; i < 3; i++) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(diceSize, diceSize, diceSize), diceMats);
        mesh.castShadow = true; 
        mesh.renderOrder = 999; // お椀より後に描画されるように強制
        scene.add(mesh); 
        diceArray.push(mesh);
        
        const body = new CANNON.Body({ mass: 1, material: mat });
        body.addShape(new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)));
        body.position.set(0, 8, 0); world.addBody(body); diceBodies.push(body);
    }
    
    // 金粉
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(450);
    for(let i=0; i<450; i++) pPos[i] = (Math.random()-0.5)*25;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({ color: 0xd4af37, size: 0.06 });
    const pMesh = new THREE.Points(pGeo, pMat); scene.add(pMesh); particles.push(pMesh);

    animate();
}

function roll() {
    if (isRolling) return;
    isRolling = true; checkSettled = false;
    document.getElementById('yaku').style.opacity = 0;
    document.getElementById('dice-vals').style.opacity = 0;
    document.getElementById('rollBtn').disabled = true;

    diceBodies.forEach((body, i) => {
        body.position.set((Math.random()-0.5), 5+i, (Math.random()-0.5));
        body.velocity.set((Math.random()-0.5)*25, -20, (Math.random()-0.5)*25);
        body.angularVelocity.set(Math.random()*50, Math.random()*50, Math.random()*50);
    });
    setTimeout(() => { checkSettled = true; }, 1200);
}

function checkAllSettled() {
    if (!checkSettled) return;
    const stopped = diceBodies.every(b => b.velocity.length() < 0.03 && b.angularVelocity.length() < 0.03);
    if (stopped) { checkSettled = false; judge(); }
}

function judge() {
    const results = diceBodies.map(body => {
        const matrix = new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w));
        const localDirs = [{v: new THREE.Vector3(1,0,0), val: 5}, {v: new THREE.Vector3(-1,0,0), val: 2}, {v: new THREE.Vector3(0,1,0), val: 6}, {v: new THREE.Vector3(0,-1,0), val: 1}, {v: new THREE.Vector3(0,0,1), val: 3}, {v: new THREE.Vector3(0,0,-1), val: 4}];
        let maxDot = -1, res = 1;
        localDirs.forEach(dir => {
            const dot = dir.v.clone().applyMatrix4(matrix).dot(new THREE.Vector3(0, 1, 0));
            if (dot > maxDot) { maxDot = dot; res = dir.val; }
        });
        return res;
    });

    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 400);

    results.sort((a, b) => a - b);
    let title = "役なし", color = "#fff";
    if (results[0] === results[1] && results[1] === results[2]) {
        if (results[0] === 1) { title = "ピンゾロ (5倍)"; color = "#ff4d4d"; }
        else { title = `ゾロ目 (${results[0]}) (3倍)`; color = "#ffd700"; }
    } else if (results[0] === 4 && results[1] === 5 && results[2] === 6) { title = "シゴロ (2倍)"; color = "#ffd700";
    } else if (results[0] === 1 && results[1] === 2 && results[2] === 3) { title = "ヒフミ (2倍払)"; color = "#4d94ff";
    } else {
        if (results[0] === results[1]) title = `${results[2]}の目`;
        else if (results[1] === results[2]) title = `${results[0]}の目`;
        else if (results[0] === results[2]) title = `${results[1]}の目`;
    }

    const yakuEl = document.getElementById('yaku');
    yakuEl.textContent = title; yakuEl.style.color = color;
    document.getElementById('dice-vals').textContent = `出目: ${results.join(" ")}`;
    yakuEl.classList.add('impact'); document.getElementById('dice-vals').style.opacity = 0.8;
    isRolling = false; document.getElementById('rollBtn').disabled = false;
}

function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    checkAllSettled();
    diceArray.forEach((mesh, i) => {
        mesh.position.copy(diceBodies[i].position);
        mesh.quaternion.copy(diceBodies[i].quaternion);
        // 中心に寄せる補助（坂にいる場合のみ）
        if(Math.abs(diceBodies[i].position.x) > 1.9 || Math.abs(diceBodies[i].position.z) > 1.9) {
            diceBodies[i].applyForce(new CANNON.Vec3(-diceBodies[i].position.x * 5, 0, -diceBodies[i].position.z * 5), diceBodies[i].position);
        }
    });
    particles.forEach(p => { p.rotation.y += 0.001; });
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('rollBtn').onclick = roll;
init();
</script>
</body>
</html>
