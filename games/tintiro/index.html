<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D 粋・チンチロリン</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: "serif"; }
        #ui { position: absolute; bottom: 20px; width: 100%; text-align: center; z-index: 10; }
        #result { position: absolute; top: 20%; width: 100%; text-align: center; font-size: 60px; color: #d4af37; text-shadow: 0 0 10px #fff; pointer-events: none; opacity: 0; transition: 0.3s; }
        button { padding: 15px 40px; font-size: 20px; background: #d4af37; border: none; cursor: pointer; border-radius: 5px; font-weight: bold; }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>

<div id="result"></div>
<div id="ui"><button id="rollBtn">勝負を振る</button></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
/** * 物理演算と3D描画の設定
 */
let world, scene, camera, renderer, diceArray = [];
const diceBodies = [];

function init() {
    // --- Cannon.js (物理エンジン) ---
    world = new CANNON.World();
    world.gravity.set(0, -9.82 * 2, 0); // 重力を少し強めに

    // --- Three.js (描画エンジン) ---
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 光源
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const spotLight = new THREE.SpotLight(0xffffff, 0.8);
    spotLight.position.set(5, 15, 5);
    spotLight.castShadow = true;
    scene.add(spotLight);

    // どんぶり（床面として）
    const floorGeo = new THREE.CylinderGeometry(5, 4, 1, 32);
    const floorMat = new THREE.MeshPhongMaterial({ color: 0x4a0404 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.position.y = -0.5;
    floor.receiveShadow = true;
    scene.add(floor);

    const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Cylinder(5, 5, 1, 32) });
    floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    world.addBody(floorBody);

    // サイコロ作成
    for (let i = 0; i < 3; i++) {
        createDice(i);
    }

    animate();
}

function createDice(i) {
    const size = 0.6;
    const geometry = new THREE.BoxGeometry(size, size, size);
    
    // サイコロのテクスチャ（簡易版）
    const materials = [];
    for(let val=1; val<=6; val++){
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white'; ctx.fillRect(0,0,64,64);
        ctx.fillStyle = val === 1 ? 'red' : 'black';
        ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
        ctx.fillText(val, 32, 45);
        materials.push(new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas) }));
    }
    
    const dice = new THREE.Mesh(geometry, materials);
    dice.castShadow = true;
    scene.add(dice);
    diceArray.push(dice);

    const shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2));
    const body = new CANNON.Body({ mass: 1 });
    body.addShape(shape);
    body.position.set(i - 1, 5, 0); // 初期位置
    world.addBody(body);
    diceBodies.push(body);
}

function rollDice() {
    document.getElementById('result').style.opacity = 0;
    diceBodies.forEach((body, i) => {
        body.position.set(Math.random() - 0.5, 6 + i, Math.random() - 0.5);
        body.velocity.set((Math.random()-0.5)*10, -10, (Math.random()-0.5)*10);
        body.angularVelocity.set(Math.random()*20, Math.random()*20, Math.random()*20);
    });

    // 停止判定後のリザルト表示（3秒後）
    setTimeout(judge3D, 3000);
}

function judge3D() {
    const results = diceBodies.map(body => getUpwardSide(body));
    const resultDiv = document.getElementById('result');
    
    // 前回の判定ロジックを流用（簡易化）
    results.sort();
    let text = results.join("-");
    
    // ここで役判定（前述のロジックと同じ）
    resultDiv.textContent = text; 
    resultDiv.style.opacity = 1;
}

// 物理演算上の回転から、どの面が上を向いているか計算
function getUpwardSide(body) {
    const ups = [
        {val: 1, vec: new THREE.Vector3(0, 0, 1)},  // Z+
        {val: 2, vec: new THREE.Vector3(0, 0, -1)}, // Z-
        {val: 3, vec: new THREE.Vector3(0, 1, 0)},  // Y+
        {val: 4, vec: new THREE.Vector3(0, -1, 0)}, // Y-
        {val: 5, vec: new THREE.Vector3(1, 0, 0)},  // X+
        {val: 6, vec: new THREE.Vector3(-1, 0, 0)}  // X-
    ];
    
    let maxDot = -1;
    let upValue = 1;
    const worldUp = new THREE.Vector3(0, 1, 0);
    const bodyQuat = new THREE.Quaternion(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);

    ups.forEach(side => {
        const direction = side.vec.clone().applyQuaternion(bodyQuat);
        const dot = direction.dot(worldUp);
        if (dot > maxDot) {
            maxDot = dot;
            upValue = side.val;
        }
    });
    return upValue;
}

function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    for (let i = 0; i < diceArray.length; i++) {
        diceArray[i].position.copy(diceBodies[i].position);
        diceArray[i].quaternion.copy(diceBodies[i].quaternion);
    }
    renderer.render(scene, camera);
}

document.getElementById('rollBtn').onclick = rollDice;
init();
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
